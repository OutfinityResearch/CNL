<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Architecture: Storage Model</title>
  <link rel="stylesheet" href="../assets/style.css" />
  <script src="../site-nav.js"></script>
</head>
<body>
  <div class="page">
    <header class="site-header">
      <div class="header-inner">
        <div class="brand">
          <div class="brand-mark" aria-hidden="true"></div>
          <div>CNL Architecture</div>
        </div>
      </div>
    </header>

    <main>
      <section class="hero">
        <span class="tag">Architecture Part 2</span>
        <h1>The Knowledge Base Engine</h1>
        <p>In-memory Bitsets and Matrices: high-performance storage for logical reasoning.</p>
      </section>

      <section class="section">
        <h2>Bitset-Oriented Design</h2>
        <p>
          Traditional databases (SQL) are Row-Oriented. They are great for retrieving a record, but slow for set operations. CNL-PL is <strong>Bitset-Oriented</strong>. The primary atom of storage is not a "Record" but a "Set".
        </p>
        <p>
          Every entity in the system is interned to a dense integer ID (0..N). A <strong>Bitset</strong> is simply a compact array of bits where the N-th bit is 1 if Entity N is in the set.
        </p>
      </section>

      <section class="section">
        <h2>The RelationMatrix</h2>
        <p>
          A binary predicate (like "user has role") is stored as a <strong>RelationMatrix</strong>.
        </p>
        <div class="code-block">
<pre>
RelationMatrix {
  rows: Bitset[]  // rows[SubjectID] -> Bitset of Objects
}
</pre>
        </div>
        <p>
          If we want to know "What roles does User_42 have?", we simply read <code>rows[42]</code>. The result is a Bitset representing the set of roles.
        </p>
        <p>
          Crucially, we maintain the <strong>Inverse Matrix</strong>. This allows us to answer "Which users have the admin role?" instantly by looking up the admin ID in the inverse matrix.
        </p>
      </section>

      <section class="section">
        <h2>Attribute Indices</h2>
        <div class="grid">
            <div class="card">
                <h3>NumericIndex</h3>
                <p>Stores primitive values like integers or floats.</p>
                <p><code>NumericIndex { values: Float64Array, hasValue: Bitset }</code></p>
                <p>Separates existence (hasValue) from magnitude, enabling fast filtering.</p>
            </div>
            <div class="card">
                <h3>EntityAttrIndex</h3>
                <p>Stores attributes that point to other entities (e.g., <code>User has a role of Admin</code>).</p>
                <p><code>EntityAttrIndex { values: Bitset[] }</code></p>
                <p>Allows attributes to behave like relations but be scoped as properties.</p>
            </div>
        </div>
      </section>

      <section class="section">
        <h2>FactID & Provenance</h2>
        <p>
          To explain "Why?", every bit in the KB must be traceable. However, storing an ID for every bit is expensive.
        </p>
        <p>
            <strong>FactID Strategy:</strong> We derive a stable 64-bit or 128-bit hash from the tuple <code>(PredID, SubjectID, ObjectID)</code>.
            This allows us to look up justification trees (provenance) in a separate store without bloating the hot reasoning path.
        </p>
      </section>
    </main>
    <footer class="site-footer"><div class="footer-inner">CNL-PL Architecture</div></footer>
  </div>
</body>
</html>