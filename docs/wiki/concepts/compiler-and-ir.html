<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Compiler Contract and Plan IR</title>
  <link rel="stylesheet" href="../../assets/style.css" />
  <script src="../../site-nav.js"></script>
</head>
<body>
  <div class="page">
    <header class="site-header">
      <div class="header-inner">
        <div class="brand">
          <div class="brand-mark" aria-hidden="true"></div>
          <div>CNL Wiki</div>
        </div>
      </div>
    </header>

    <main>
      <section class="hero">
        <span class="tag">Concepts</span>
        <h1>Compiler Contract and Plan IR</h1>
        <p>The gap between static text and dynamic execution is bridged by the Plan Intermediate Representation.</p>
      </section>

      <section class="section">
        <h2 id="compiler">The Compiler Contract</h2>
        <p>
          In many interpreted languages, the AST is executed directly (tree-walking). CNL-PL takes a different approach: it compiles the AST into a flat, optimized <strong>IR (Intermediate Representation)</strong> known as the Plan.
        </p>
        <p>
          The <strong>Compiler Contract</strong> guarantees determinism. It states that for any given AST and any given dictionary state, the compiler will produce exactly the same sequence of Plan instructions. This separation enables the "Write Once, Run Anywhere" philosophy for pragmatics: the same compiled Plan can be sent to a local in-memory engine, a remote SQL backend, or a specialized SMT solver.
        </p>

        <h2 id="plans">The Plan Types</h2>
        <p>
          The Plan IR is typed. It does not just say "Execute X"; it specifies what <em>kind</em> of result X produces. This prevents runtime type errors and allows for aggressive optimization.
        </p>
        <div class="grid">
          <div class="card">
            <h3>SetPlan</h3>
            <p>Produces a <strong>Bitset</strong> of entities. Used for queries like "Find all users". Operations include Intersection (AND), Union (OR), and Difference (NOT).</p>
          </div>
          <div class="card">
            <h3>BoolPlan</h3>
            <p>Produces a single <strong>Boolean</strong> (true/false). Used for "Verify" commands and rule conditions. It efficiently checks if a SetPlan result is empty or not.</p>
          </div>
          <div class="card">
            <h3>RelationPlan</h3>
            <p>Produces a <strong>RelationMatrix</strong> (rows of bitsets). Used for complex joins, like "Find users who manage servers that have high load".</p>
          </div>
          <div class="card">
            <h3>NumberPlan</h3>
            <p>Produces a <strong>Numeric</strong> value. Used for aggregations ("Count of users") or attribute lookups ("Average salary").</p>
          </div>
        </div>

        <h2 id="executable">ActionPlan and RulePlan</h2>
        <p>
          Beyond simple queries, the system compiles behaviors. An <strong>ActionPlan</strong> is the compiled form of an Action Block. It contains a Precondition (a BoolPlan tree) that determines if the action is valid, and a set of Effect Deltas that describe how to mutate the KB if the action succeeds.
        </p>
        <p>
          Similarly, a <strong>RulePlan</strong> is a specialized structure for deduction. It contains a Body (the "IF" part, compiled to a Plan) and a Head (the "THEN" part). The execution engine runs these RulePlans in a loop (fixpoint iteration) to derive all possible consequences of the current state.
        </p>
      </section>
    </main>
    <footer class="site-footer"><div class="footer-inner">CNL-PL Wiki</div></footer>
  </div>
</body>
</html>
